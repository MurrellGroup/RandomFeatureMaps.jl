var documenterSearchIndex = {"docs":
[{"location":"#RandomFeatureMaps","page":"Home","title":"RandomFeatureMaps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RandomFeatureMaps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#RandomFeatureMaps.RandomFourierFeatures","page":"Home","title":"RandomFeatureMaps.RandomFourierFeatures","text":"RandomFourierFeatures(n => m, σ)\n\nMaps n-dimensional data and projects it to m-dimensional random fourier features.\n\nThis type has no trainable parameters.\n\nExamples\n\njulia> rff = RandomFourierFeatures(2 => 4, 1.0); # maps 2D data to 4D\n\njulia> rff(rand(2, 3)) |> size # 3 samples\n(4, 3)\n\njulia> rff(rand(2, 3, 5)) |> size # extra batch dim\n(4, 3, 5)\n\n\n\n\n\n","category":"type"},{"location":"#RandomFeatureMaps.RandomOrientationFeatures","page":"Home","title":"RandomFeatureMaps.RandomOrientationFeatures","text":"RandomOrientationFeatures\n\nHolds two random matrices which are used to embed rigid transformations.\n\nThis type has no trainable parameters.\n\nMethods\n\n(::RandomOrientationFeatures)(rigid1, rigid2): returns the distances between the corresponding\n\nrigid transformations, embedded using the two random matrices of the random orientation features.\n\n(::RandomOrientationFeatures)(rigid1, rigid2; dims::Int): unsqueezes batch dimension dim+1\n\nof rigid1 and dim of rigid2 to broadcast the rof call and produce a pairwise map.\n\n(::RandomOrientationFeatures)(rigid1, rigid2, graph::GraphNeuralNetworks.GNNGraph): similar to\n\nthe first method, but takes two sets rigid transformations of equal size and unrolls a graph to get the pairs of rigid transformations. Equivalent to the second method (with broadcasted dimensions flattened) when the graph is complete.\n\nEach of these have single rigid argument methods for when rigid1 == rigid2, i.e. rof(rigid)\n\nExamples\n\njulia> rof = RandomOrientationFeatures(10, 0.1f0);\n\njulia> rigid = rand_rigid(Float32, (4, 3));\n\njulia> rof(rigid, rigid) |> size\n(10, 4, 3)\n\njulia> rigid1, rigid2 = rand_rigid(Float32, (4, 2)), rand_rigid(Float32, (3, 2));\n\njulia> rof(rigid1, rigid2; pairdim=1) |> size\n(10, 4, 3, 2)\n\njulia> using GraphNeuralNetworks\n\njulia> graph = GNNGraph(Bool[1 0; 1 1], graph_type=:dense)\nGNNGraph:\n  num_nodes: 2\n  num_edges: 3\n\njulia> rigid = rand_rigid(Float32, (2,));\n\njulia> rof(rigid, graph) |> size\n(10, 3)\n\n\n\n\n\n","category":"type"},{"location":"#RandomFeatureMaps.RandomOrientationFeatures-Tuple{Integer, AbstractFloat}","page":"Home","title":"RandomFeatureMaps.RandomOrientationFeatures","text":"RandomOrientationFeatures(m, σ)\n\nCreates a RandomOrientationFeatures instance, mapping to m features.\n\n\n\n\n\n","category":"method"},{"location":"#RandomFeatureMaps.RandomTriangleFeatures","page":"Home","title":"RandomFeatureMaps.RandomTriangleFeatures","text":"RandomFourierFeatures(n => m, σ)\n\nMaps n-dimensional data and projects it to m-dimensional random fourier features.\n\nThis type has no trainable parameters.\n\nExamples\n\njulia> rff = RandomFourierFeatures(2 => 4, 1.0); # maps 2D data to 4D\n\njulia> rff(rand(2, 3)) |> size # 3 samples\n(4, 3)\n\njulia> rff(rand(2, 3, 5)) |> size # extra batch dim\n(4, 3, 5)\n\n\n\n\n\n","category":"type"},{"location":"#RandomFeatureMaps.TrainableRBF","page":"Home","title":"RandomFeatureMaps.TrainableRBF","text":"TrainableRBF(n => m, [σ])\n\nMaps n-dimensional data to m Gaussian radial basis responses with trainable centers and isotropic radii per basis.\n\nThe optional σ controls the initialization scale and element type.\n\nExamples\n\njulia> rbf = TrainableRBF(2 => 4, 1.0); # 4 bases in 2D\n\njulia> rbf(rand(2, 3)) |> size # 3 samples\n(4, 3)\n\njulia> rbf(rand(2, 3, 5)) |> size # extra batch dim\n(4, 3, 5)\n\n\n\n\n\n","category":"type"},{"location":"#RandomFeatureMaps.get_rigid-Tuple{AbstractArray, AbstractArray}","page":"Home","title":"RandomFeatureMaps.get_rigid","text":"get_rigid(R::AbstractArray, t::AbstractArray)\n\nConverts a rotation R and translation t to a BatchedTransformations.Rigid, designed to handle batch dimensions.\n\nThe transformation gets applied according to NNlib.batched_mul(R,  x) .+ t\n\n\n\n\n\n","category":"method"}]
}
